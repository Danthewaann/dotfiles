#!/usr/bin/env python3

import argparse
import os
import re
import shutil
import sys
import subprocess
import pathlib
import time
from typing import Any
import _utils


def validate_working_dir(value: Any) -> pathlib.Path | None:
    if not value:
        return None

    working_dir = pathlib.Path(value)
    if not working_dir.exists():
        # If this directory doesn't exist, check if it exists under my directory
        # This is useful for switching to my forks of github repos
        working_dir = pathlib.Path("Danthewaann") / working_dir.name

        if not working_dir.is_dir():
            raise argparse.ArgumentTypeError("must provide a valid directory")

    return working_dir


parser = argparse.ArgumentParser(prog="gitw-add")
parser.add_argument("branch")
parser.add_argument("args", nargs="*")
parser.add_argument("-C", dest="working_dir", type=validate_working_dir)

parsed_args = parser.parse_args()
branch_name = parsed_args.branch
args = parsed_args.args
working_dir = parsed_args.working_dir

if working_dir:
    os.chdir(working_dir)

# If the branch name starts with `origin/` remove that section
if branch_name.startswith("origin/"):
    branch_name = branch_name.split("/", 1)[1]

# Convert all forward slashes to dashes and dots to underscores as tmux sessions can't contain dots
converted_name = branch_name.replace("/", "-").replace(".", "_")

# If we are already inside a worktree change directory to the bare repo
if _utils.inside_worktree():
    base_repo = _utils.get_worktree()
    os.chdir(pathlib.Path(base_repo).parent)

# Make sure we are inside a bare repo before proceeding
if not _utils.inside_bare_repo():
    _utils.error("Must be run in a worktree or bare repository!")
    sys.exit(1)

# If the worktree already exists, switch to it
if pathlib.Path(converted_name).is_dir():
    _utils.info("Switching to worktree...")
    sys.exit(
        subprocess.run(
            ["tmux-sessionizer", pathlib.Path.cwd() / converted_name, *args]
        ).returncode
    )

# If we get to this point, the branch hasn't been checked out into a worktree yet
# When running `git fetch` remote branch info will be fetched, meaning theses branches
# will appear as if they have been created locally when we run `git branch` below.
proc = _utils.run_git_fetch()
if proc.returncode != 0:
    sys.exit(1)

print(file=sys.stderr)

base_branch = _utils.get_base_branch()

# Create or reset the branch at this point. Any commits in this branch that
# don't match what's in the remote will be removed. I don't think this will
# cause any problems for my workflow, as I always associate a branch with a
# physical checkout.
local_branch_arg = ["-B", branch_name]

# If this branch exists remotely, set up tracking info for the local branch
remote_tracking_arg = []
remote_branches = subprocess.run(
    ["git", "branch", "-r"], text=True, capture_output=True
).stdout
if re.search(rf"\w*origin/{branch_name}$", remote_branches, re.MULTILINE):
    remote_tracking_arg = ["--track", f"origin/{branch_name}"]

# Create a new worktree using the converted name whilst checking out the branch
_utils.info("Creating worktree...")

add_args = [
    "git",
    "worktree",
    "add",
    converted_name,
    *local_branch_arg,
    *remote_tracking_arg,
]

proc = subprocess.run(
    add_args, text=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT
)
if proc.stdout:
    print(proc.stdout.rstrip(), file=sys.stderr)
if proc.returncode != 0:
    sys.exit(1)

# Copy the .vim folder so I can reuse global marks and history
base_repo = _utils.get_worktree()
vim_dir = base_repo / ".vim"
if vim_dir.exists():
    shutil.copytree(vim_dir, f"{converted_name}/.vim")

# Enter the new worktree
os.chdir(converted_name)

# Post checkout steps
_utils.update_python_deps()

print(file=sys.stderr)
_utils.success("Successfully created worktree!")
print(file=sys.stderr)
_utils.info("Switching to worktree...")
time.sleep(0.3)
sys.exit(subprocess.run(["tmux-sessionizer", pathlib.Path.cwd(), *args]).returncode)
