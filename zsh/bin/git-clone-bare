#!/usr/bin/env python3

import json
import os
import pathlib
import re
import subprocess
import sys
import _utils
import argparse

# From: https://morgan.cugerone.com/blog/workarounds-to-git-worktree-using-bare-repository-and-cannot-fetch-remote-branches/
#
# Examples of call:
# git-clone-bare git@github.com:name/repo.git
# => Clones to a /repo directory
#
# git-clone-bare git@github.com:name/repo.git my-repo
# => Clones to a /my-repo directory


def validate_value(value: str) -> pathlib.Path:
    if value.startswith("git@github.com"):
        _, value = value.split(":")
        value = value.removesuffix(".git")
        return pathlib.Path(value)
    elif re.match(r"^[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+$", value):
        return pathlib.Path(value)
    else:
        raise argparse.ArgumentTypeError(
            "Invalid value provided, must be a 'git@github.com' url or a '<user>/<repo>' string"
        )


parser = argparse.ArgumentParser(prog="git-clone-bare")
parser.add_argument("value", metavar="[GIT_URL or <USER>/<REPO>]", type=validate_value)

if len(sys.argv) < 2:
    parser.print_usage()
    sys.exit(1)

args = parser.parse_args()
value: pathlib.Path = args.value

if value.exists():
    _utils.error(f"{value} already exists!")
    sys.exit(1)

value.mkdir(parents=True, exist_ok=True)
os.chdir(value)

# Moves all the administrative git files (a.k.a $GIT_DIR) under .bare directory.
#
# Plan is to create worktrees as siblings of this directory.
# Example targeted structure:
# .bare
# main
# new-awesome-feature
# hotfix-bug-12
# ...
print(file=sys.stderr)
_utils.info(f"Cloning bare {value} repository...")
proc = _utils.run_command(
    ["git", "clone", "--bare", f"git@github.com:{value}.git", ".bare"]
)
if proc.returncode != 0:
    sys.exit(1)

with open(".git", "w") as git_file:
    git_file.write("gitdir: ./.bare\n")

# Explicitly sets the remote origin fetch so we can fetch remote branches
proc = subprocess.run(
    ["git", "config", "remote.origin.fetch", "+refs/heads/*:refs/remotes/origin/*"]
)
if proc.returncode != 0:
    sys.exit(1)

# Gets all branches from origin
print(file=sys.stderr)
_utils.info("Fetching remote branches...")
proc = _utils.run_command(["git", "fetch", "origin"])
if proc.returncode != 0:
    sys.exit(1)

print(file=sys.stderr)
_utils.info("Setting default repo...")
proc = _utils.run_command(
    [
        "gh",
        "repo",
        "set-default",
        value,
    ]
)
if proc.returncode != 0:
    sys.exit(1)

print(file=sys.stderr)
_utils.info("Fetching parent settings...")
proc = subprocess.run(
    [
        "gh",
        "repo",
        "view",
        "--json",
        "parent",
        "--json",
        "isFork",
    ],
    text=True,
    stdout=subprocess.PIPE,
    stderr=subprocess.STDOUT,
)
if proc.returncode != 0:
    sys.exit(1)

settings = json.loads(proc.stdout)

if not settings["isFork"]:
    print(
        f"{_utils.YELLOW}This repo is not a fork, skipping upstream fetch{_utils.NC}",
        file=sys.stderr,
    )
else:
    owner = settings["parent"]["owner"]["login"]
    print(file=sys.stderr)
    _utils.info("Fetching upstream branches...")
    proc = _utils.run_command(
        [
            "git",
            "remote",
            "add",
            "upstream",
            f"https://github.com/{owner}/{value.name}.git",
        ]
    )
    if proc.returncode != 0:
        sys.exit(1)
    proc = _utils.run_command(["git", "fetch", "upstream"])
    if proc.returncode != 0:
        sys.exit(1)

# Creating base worktree
print(file=sys.stderr)
_utils.info("Creating base worktree...")
print(file=sys.stderr)
base_branch = _utils.get_base_branch()
subprocess.run(["gitw-add", base_branch])
